\subsubsection{Definici\'on de la Vecindad y funci\'on objetivo}
\par A al hora de implementar una heur\'istica de b\'usqueda local, lo principal
    que se debe hacer es definir la \emph{vecindad} y la funci\'on objetivo que
    se intenta maximizar, ya que el esquema de est\'a heur\'istica est\'a ya definida.

\par En el marco de este trabajo, definimos estos dos par\'ametros de
    la heur\'istica de la siguiente manera:

\begin{itemize}
    \item \textbf{Funci\'on Objetivo:} En nuestro caso particular, lo que
        deseamos maximizar es la frontera de la clique que se quiere
        encontrar. Es razonable entonces, establecer a la \emph{frontera}
        como funci\'on objetivo.

    \item \textbf{Vecindad:\label{bl:vecindad}} Como estamos buscando una clique en particular,
        y esta misma se compone de nodos en un grafo y el subgrafo que inducen,
        es razonable pensar en una vecindad compuesta de cliques. Por lo tanto,
        incialmente planteamos una vecindad compuesta de todas las cliques
        que tienen un nodo m\'as o uno menos respecto de la clique actual que
        se tiene al momento de recorrer los vecinos.
\end{itemize}

\par Tratando de ahondar un poco m\'as en los motivos de esta \'ultima
    definici\'on, cabe destacar que buscamos una vecindad no muy costosa
    de recorrer (pues sino se acercar\'ia al costo de revisar todas las
    posibilidades, es decir, un \emph{backtracking}), pero a su vez lo
    suficientemente poblada como para que se pueda mejorar la funci\'on
    objetivo iteraci\'on a iteraci\'on.

\par No se puede saber, a ciencia cierta, si una vecindad ser\'a muy grande
    o muy chica. O si ser\'a ``buena'' o ``mala''\footnote{Para alguna definici\'on
    de ``bueno''/``malo'', en nuestro caso ser\'ia la complejidad y lo
    cercano de la soluc\'on devuelta respecto del \'optimo.}. As\'i pues,
    m\'as all\'a de la intuci\'on, m\'as adelante en la secci\'on~\ref{bl:variantes},
    \emph{\nameref{bl:variantes}} se plantea una variante de esta vecindad.

\subsubsection{La heur\'istica de b\'usqueda local}
\par Habiendo ya definido la funci\'on objetivo y la vecindad, la explicaci\'on
    del heur\'istica es un tanto trivial (al menos para explicarla, ya que al
    hablar de la complejidad y las estructuras de datos utilizadas esto deja
    de serlo).

\par El primer paso de nuestro algoritmo es seleccionar una clique inicial
    al partir del cual se comenzar\'a con el recorrido de su vecindad asociada.
    Esto es necesario ya que el concepto de vecindad implica tener ya una
    soluci\'on parcial a partir de la cual definir sus vecinos. En nuestra
    primera versi\'on de esta heur\'istica, decidimos seleccionar alg\'un
    nodo tal que sea de grado mayor o igual al grado promedio del grafo (es
    decir, la suma de todos los grados dividio la cantidad de nodos). La
    idea b\'asica detr\'as de esta forma de selecci\'on de la clique incial
    es tener al menos alguna arista que nos asegure alg\'un vecino (como se
    explic\'on en la Secci\'on \emph{\nameref{notas_preliminares}},
    \emph{\nameref{notas:conexos}} el grafo es conexo por lo cual seguro tendremos
    al menos alg\'un nodo con una arista\footnote{Excepto para el grafo trivial.}).

\par Siguiendo con los pasos que definen a la heur\'istica de b\'usqueda local,
    y asumiendo que ya se tiene una clique inicial, se recorre la vecindad
    definida y se ``salta'' a alg\'un vecino encontrado que mejore la
    funci\'on objetivo. Cuando esto no sea posible (ya que no hay un vecino
    que cumpla con esta condici\'on), la heur\'istica termina.

\par Como puede notar el lector, en ning\'un momento se ha definido alg\'un
    parametro de selecci\'on del vecino al cual moverse (en caso de haber
    m\'as de uno que permita aumentar la funci\'on objetivo). M\'as informaci\'on
    sobre esto ser\'a detallada en la Secci\'on~\ref{bl:variantes}.

\subsubsection{Pseudoc\'odigo descriptivo}
\par Se presenta a continuaci\'on un pseudoc\'odigo que describe los pasos que sigue
    nuestra heur\'istica propuesta. El mismo no contempla estructuras de datos sobre
    los cuales se implement\'o (cosa que se realiza en el c\'alculo de complejidad),
    simplemente tiene como objetivo describir los pasos de la heur\'istica.

\bigskip

\begin{pseudocodigo}[Heur\'istica de B\'usqueda Local para \emph{CMF} - Descriptivo]
    \Require\Statex
        \begin{itemize}
            \item Un grafo $G$ de $n$ v\'ertices\footnote{Asumimos, sin p\'erdida 
                de generalidad, que los v\'ertices est\'an numerados de 1 a $n$.}
                y $m$ aristas.

            \item Una funci\'on $candidatos(K)$, que dado un conjunto de v\'ertices
                $K$, devuelve una secuencia de v\'ertices de $G$ ordenada por grado
                de mayor a menor que son adjacentes a todos los elementos de $K$ y
                cuyo grado es mayor $2|K|$.

            \item Una funci\'on $\delta(K)$, que dada una \emph{clique} $K$ en $G$, calcula
                el cardinal de su frontera\footnote{Como ya se explic\'o, sea $K$ una
                \emph{clique} de $G$, entonces: $\delta(K) = - |K|(|K|-1) +
                \displaystyle\sum_{v \in K} d(v)$}.
        \end{itemize}

    \Statex
    \Ensure Una \emph{clique} $K$ de $G$ con una frontera $\delta(K)$ que se
        espera que sea de cardinalidad cercana o igual a la de $\delta(K_{max})$,
        siendo $K_{max}$ la \emph{clique} de m\'axima frontera de $G$.

    \Statex
    \State $K \gets \emptyset$
    \If{$G$ es un grafo completo $K_n$}
        \State $K \gets \lfloor\sfrac{n}{2}\rfloor$ nodos distintos de $V(G)$ cualesquiera.
        \Statex

    \Else
        \State $v_{add} \gets v \in V(G)$ tal que $d(v) \geq \sfrac{2m}{n}$
        \State $v_{rem} \gets NULL$
        \While{$v_{add} \neq NULL$ $\lor$ $v_{rem} \neq NULL$}
            \If{$\delta(K+v_{add}) > \delta(K-v_{rem})$}
                \State $K \gets K+v_{add}$
            \Else
                \State $K \gets K-v_{rem}$
            \EndIf

            \Statex
            \If{$\exists v \in candidatos(K)$ tal que $\delta(K+v) > \delta(K)$}
                \State $v_{add} \gets v$

            \Else
                \State $v_{add} \gets NULL$
            \EndIf

            \Statex
            \If{$\exists v \in V(K)$ tal que $\delta(K-v) > \delta(K)$}
                \State $v_{rem} \gets v$

            \Else
                \State $v_{rem} \gets NULL$
            \EndIf
        \EndWhile
    \EndIf

    \State \Return{$K$}
\end{pseudocodigo}

\subsubsection{Variantes}\label{bl:variantes}
\par La idea del algoritmo, una vez definidas la vecindad y la funci\'on objetivo,
    consiste en iterar mientras se pueda incrementar la funci\'on objetivo mediante
    el ``salto'' a alg\'un \emph{vecino}. La heur\'istica se detiene cuando
    esto no es posible mediante alguno de los vecinos actuales.

\par As\'i pues, se puede notar como una vecindad muy chica podr\'ia hacer
    terminar a la heur\'istica tempranamente, sin llegar a una buena soluci\'on.

\par Como ya se mencion\'o, la contraparte (tener una vecindad muy grande) podr\'ia
    llegar a ser muy costoso temporalmente, ya que se requiere m\'as tiempo para
    poder recorrer la vecindad.

\par As\'i pues, se decidi\'o presentar una serie de variantes para luego poder
    comparar distintos resultados en la \emph{experimentaci\'on}:

\begin{itemize}
    \item \textbf{Vecindad con intercambio:} Decidimos presentar una variante
        para la vecindad definida. Esta en cuesti\'on ampl\'ia el tama\~no
        de la vecindad definida en~\ref{bl:vecindad}, incluyendo tambi\'en a aquellas
        cliques que tengan el mismo tam\~no que la clique actual pero difieran
        exactamente en un nodo. Es decir, con esta extensi\'on, consideramos
        en la vecindad a todas las cliques que tengan un nodo menos, uno m\'as o
        uno distinto respecto de la clique actual.

    \item \textbf{Clique Inicial Golosa:} La heur\'istica de b\'usqueda local parte
        de una clique y su vecindad, para luego ir movi\'endose entre vecinos
        que incrementen la funci\'on objetivo. En la versi\'on original
        planteada por este trabajo, se decidi\'o comenzar por una clique compuesta
        de un s\'olo nodo, que ser\'ia alg\'un nodo que tiene igual o mayor
        grado que el grado promedio por nodo del grafo\footnote{Definimos grado
        promedio como la suma de todos los grados dividio la cantidad de nodos.}.
        As\'i pues, se plantea la siguiente pregunta: ¿es capaz esta heur\'istica
        de mejorar una soluci\'on aproximada ya dada? Con las herramientas dadas,
        decidimos entonces considerar comenzar la b\'usqueda local con la clique
        que nos da la heur\'istica golosa, para luego comparar los resultados.

    \item \textbf{Primer Vecino vs Mejor Vecino:} Una vez recorrida la vecindad,
        podr\'ia pasar que haya m\'as de un vecino que permita mejorar la
        funci\'on objetivo. M\'as a\'un, ¿tiene sentido recorrer toda la vecindad
        si ya se encontr\'o un vecino que mejora la soluci\'on actual? B\'asicamente,
        se plantea la posibilidad entre recorrer toda la vecindad y escoger al
        \emph{mejor vecino}\footnote{Definido como aquel que m\'as incrementa
        la funci\'on objetivo} o quedarnos con la primera opci\'on que cumpla
        lo requerido. En el primer caso estaremos mejorando la soluci\'on m\'as
        r\'apidamente, pero tendremos un costo mayor al recorrer la vecindad. En
        el segundo caso ocurre lo contrario. As\'i pues, decidimos evaluar
        ambas posibilidades y comparar los resultados.
\end{itemize}

\bigskip

\subsubsection{Pseudoc\'odigo descriptivo con la vecindad extendida}
\par Se presenta a continuaci\'on un pseudoc\'odigo que describe los pasos que sigue
    nuestra heur\'istica propuesta con la vecindad extendida. Al igual que en el
    pseudoc\'odigo anterior, el mismo no contempla estructuras de datos sobre
    los cuales se implement\'o (cosa que se realiza en el c\'alculo de complejidad),
    simplemente tiene como objetivo describir los pasos de la variante.

\bigskip
\begin{pseudocodigo}[Heur\'istica de B\'usqueda Local para \emph{CMF} con intercambio - Descriptivo]
    \Require\Statex
        \begin{itemize}
            \item Un grafo $G$ de $n$ v\'ertices\footnote{Asumimos, sin p\'erdida 
                de generalidad, que los v\'ertices est\'an numerados de 1 a $n$.}
                y $m$ aristas.

            \item Una funci\'on $candidatos(K)$, que dado un conjunto de v\'ertices
                $K$, devuelve una secuencia de v\'ertices de $G$ ordenada por grado
                de mayor a menor que son adjacentes a todos los elementos de $K$ y
                cuyo grado es mayor $2|K|$.

            \item Una funci\'on $\delta(K)$, que dada una \emph{clique} $K$ en $G$, calcula
                el cardinal de su frontera.
        \end{itemize}

    \Statex
    \Ensure Una \emph{clique} $K$ de $G$ con una frontera $\delta(K)$ que se
        espera que sea de cardinalidad cercana o igual a la de $\delta(K_{max})$,
        siendo $K_{max}$ la \emph{clique} de m\'axima frontera de $G$.

    \Statex
    \State $K \gets \emptyset$
    \If{$G$ es un grafo completo $K_n$}
        \State $K \gets \lfloor\sfrac{n}{2}\rfloor$ nodos distintos de $V(G)$ cualesquiera.
        \Statex

    \Else
        \State $v_{add} \gets v \in V(G)$ tal que $d(v) \geq \sfrac{2m}{n}$
        \State $v_{rem} \gets NULL$
        \State $v_{exchIN} \gets NULL$, $v_{exchOUT} \gets NULL$
        \Statex
        \While{%
        $\begin{pmatrix}
            \text{\Huge{$\bigvee$}} &
            \begin{matrix}
                v_{add} \neq NULL\\
                v_{rem} \neq NULL\\
                v_{exchIN} \neq NULL$ $\land$ $v_{exchOUT} \neq NULL
            \end{matrix}
        \end{pmatrix}$%
        }

            \Statex
            \If{$\delta(K+v_{add}) > \delta(K-v_{rem})$ $\land$
            $\delta(K+v_{add}) > \delta(K-v_{exchOUT}+v_{exchIN})$}
                \State $K \gets K+v_{add}$

            \ElsIf{$\delta(K-v_{rem}) > \delta(K-v_{exchOUT}+v_{exchIN})$}
                \State $K \gets K-v_{rem}$

            \Else
                \State $K \gets \delta(K-v_{exchOUT}+v_{exchIN})$
            \EndIf

            \Statex
            \If{$\exists v \in candidatos(K)$ tal que $\delta(K+v) > \delta(K)$}
                \State $v_{add} \gets v$

            \Else
                \State $v_{add} \gets NULL$
            \EndIf

            \Statex
            \If{$\exists v \in V(K)$ tal que $\delta(K-v) > \delta(K)$}
                \State $v_{rem} \gets v$

            \Else
                \State $v_{rem} \gets NULL$
            \EndIf

            \Statex
            \If{$\exists v \in V(K)$ tal que $\exists v' \in V(K-v)$, $\delta(K-v+v') > \delta(K)$}
                \State $v_{exchIN} \gets v'$
                \State $v_{exchOUT} \gets v$

            \Else
                \State $v_{exchIN} \gets NULL$
                \State $v_{exchOUT} \gets NULL$
            \EndIf
        \EndWhile
    \EndIf

    \State \Return{$K$}
\end{pseudocodigo}
