\phantomsection
\addcontentsline{toc}{subsection}{Notas sobre la Experimentaci\'on}
\subsection*{Notas sobre la Experimentaci\'on}\label{aclaraciones}
	\par Llegados a esta instancia del ejercicio, lo que nos importa es poder
		comprobar emp\'iricamente las conclusiones te\'oricas, particularmente
		las relacionadas con la complejidad del algoritmo (ya en el punto anterior
		pudimos comprobar -por lo menos hasta un punto razonable- que el algoritmo
		es correcto). 
	\par Entonces nos encontramos en la situaci\'on de tratar de "medir"
		la complejidad del algoritmo propuesto e implementado. Solo que aqu\'i ya no podremos
		comprobar que el resultado devuelto por el algoritmo es correcto por dos
		motivos en especial: llegaremos a un punto donde probaremos con instancias
		muy grandes como para saber a ciencia cierta cual debe ser el resultado y
		pues decidimos darle un grado importante (sino principal) de aletoriedad
		a la selecci\'on/generaci\'on de estas intancias.
	\par Para medir la complejidad se decidi\'o usar el \emph{clock} del sistema,
		el mismo es un n\'umero global relacionado al hardware/sistema operativo
		que se incrementa con cada instrucci\'on ejecutada por el ordenador. La idea
		es tomar este n\'umero \footnote{\url{http://www.cplusplus.com/reference/ctime/clock/}}
		justo antes e inmediatamente despu\'es de que corra nuestro algoritmo 
		(dejando de lado -siguiendo las directivas del enunciado de este TP- 
		todas aquellas funcionalidades encargadas de cosas ajenas, como
		por ejemplo el parseo de los datos de entrada/salida). Luego, alcanza con
		calcular la diferencia entre estos dos valores para saber cu\'anto tiempo
		insumi\'o el programa para arribar a una soluci\'on.
	\par El problema de esta metodolog\'ia para medir la complejidad es que no
		toma en cuenta que junto con nuestro algoritmo se encuentra ejecut\'ando
		muchas otras aplicaciones (\emph{Winning Eleven, Mortal Kombat, etc}, las
		cuales "comparten" el tiemp de CPU. Es decir, el sistema operativo podr\'ia
		(m\'as a\'un, lo hace) desalojar nuestra tarea del procesador y pasar a
		ejecutar otras cosas. Luego ser\'a nuevamente el turno de nuestra
		aplicaci\'on, la que podr\'a terminar. Pero mientras todo esto ocurr\'ia,
		el contador global de "clock" del sistema sigui\'o increment\'andose. Es
		decir, no llegamos a una medida exacta de lo que tar\'o nuestro programa.
	\par Por estos motivos decidimos, para cada instancia del problema, ejecutarla
		m\'as de una vez (10 veces, en particular) y luego sacar el promedio. As\'i 
		conseguimos eliminar \emph{Outliers} y poder decir que tenemos una medida
		lo suficientemente precisa.
