\phantomsection
\addcontentsline{toc}{subsection}{Sobre las referencias de este documento}
\subsection*{Sobre las referencias de este documento}
\par A lo largo de este informe existen referencias tanto a \emph{papers}
    encontrados durante la elaboraci\'on de las resoluciones como as\'i
    referencias a cap\'itulos espec\'ificos de libros que son parte de la
    bibliograf\'ia de la materia.

\par Los mismos han sido puestos a disposici\'on del corrector en un repositorio
    de archivos \emph{online}, cuya direcci\'on \emph{web} est\'a inclu\'ida
    en los archivos provistos con este documento.

\phantomsection
\addcontentsline{toc}{subsection}{Sobre la compilaci\'on de los archivos fuente}
\subsection*{Sobre la compilaci\'on de los archivos fuente}
\par En los archivos provistos junto con este trabajo se pueden distinguir dos
    directorios donde hay archivos fuentes compilables: \emph{src} y
    \emph{experimentaci\'on}. En ambos hay ya un archivo \emph{Makefile} con el
    cual se pueden compilar todos los binarios desarrollados y utilizados en
    el marco de este trabajo.

\par Cabe destacar, que en la implementaci\'on provista, se permite compilar
    dichos binarios con un dise\~no \emph{multi-thread}\footnote{\url{%
    http://www.openmp.org}}, donde cada \emph{hilo} de ejecuci\'on tomar\'a
    una instancia distinta del problema provista por el \emph{standard input}
    y la resolver\'a con el algoritmo correspondiente en paralelo. Esto nos
    permite ejecutar muchas instancias en simult\'aneo, pero sin afectar
    el tiempo medido (ya que cada \emph{thread} es resuelta en un procesador
    diferente). En caso de querer compilar de esta manera los binarios, se
    debe ejecutar el siguiente comando desde el directorio \emph{src} o
    \emph{experimentaci\'on}:

\bigskip
\par make EXTRACXXFLAGS=-fopenmp
\bigskip

\par Para poder compilar el binario de esta manera, se requiere tener la 4.4
    o superior del compilador \emph{GNU Compiler Collection}\footnote{\url{%
    http://gcc.gnu.org/}}.

\phantomsection
\addcontentsline{toc}{subsection}{Sobre los generadores de instancias aleatorias}
\subsection*{Sobre los generadores de instancias aleatorias}
\par Una vez que se implementaron los algoritmos que resuelven los problemas
    presentados por el enunciado de este trabajo, se llega a la etapa de
    an\'alisis/experimentaci\'on donde se quieren verificar los resultados
    te\'oricos obtenidos con informaci\'on emp\'irica. Para ello, en cada caso/%
    algoritmo, se hizo un an\'alisis sobre alg\'un subconjunto/familia de grafos
    de inter\'es (explicado en cada caso particular durante este informe). Luego,
    se implement\'o un generador de instancias aleatorias para estas familias
    (el cual es compilado seg\'un como se indica en el punto anterior) el cual,
    mediante una interfaz de men\'u por l\'inea de comando, nos permite seleccionar
    la familia, el tama\~no de las instancias a generar, cuantas instancias por
    tama\~no generar y el archivo donde se desea guardar toda esta informaci\'on%
    \footnote{Puede ocurrir que para ciertas familias se requiera alg\'un otro dato,
    el cual ser\'a demandado al usuario por la pantalla.}.

\par El concepto de aleatoriedad en estos generadores ocurre a la hora de elegir
    los extremos de las aristas (siempre preservando la estructura de la familia
    elegida). Para poder hacer esta selecci\'on aleatoria, se utilizaron funciones
    del a \emph{STL} de \emph{C} portadas a \emph{C++}\footnote{%
    \url{http://www.cplusplus.com/reference/cstdlib/rand/}} y algunas de la
    \emph{STL} nativa de \emph{C++}\footnote{%
    \url{http://www.cplusplus.com/reference/algorithm/random_shuffle/}}.

\par Hay una familia de grafos particular que merece una menci\'on aparte dada
    la manera en la que implementamos su generador. Esta es la familia de los
    grafos \emph{planares}\footnote{Claude Berge. Planar Graphs. \emph{The Theory
    of Graphs}, 21:207-2013, 1966.}. La generaci\'on de esta familia convella
    una mayor dificultad, m\'as a\'un, es un problema en si mismo que ha sido
    y es estudiado a\'un\footnote{\'Eric Fusy. Uniform Random Sampling Of Planar
    Graphs in Linear Time.}. Por este motivo, se decidi\'o utilizar una
    biblioteca de funciones de \emph{C++} que ya nos provee dicho generador
    de grafos aleatorios\footnote{\url{http://www.ogdf.net/}}. Sus archivos
    fuentes son provistos junto con este trabajo como as\'i tambi\'en su
    compilaci\'on fue configurada en los \emph{Makefile}'s ya mencionados en
    esta secci\'on.\footnote{La versi\'on de \emph{python} 2.7 es requerida para
    que esto funcione sin ninguna modificaci\'on.}.

\phantomsection
\addcontentsline{toc}{subsection}{Sobre la experimentaci\'on}
\subsection*{Sobre la experimentaci\'on}
\par Llegados a esta instancia del ejercicio, lo que nos importa es poder
    comprobar emp\'iricamente las conclusiones te\'oricas, particularmente
    las relacionadas con la complejidad temporal y "cuan bueno" son los
    algoritmos/heur\'isticas.

\par Entonces nos encontramos en la situaci\'on de tratar de "medir"
    la complejidad del algoritmo propuesto e implementado. Solo que aqu\'i ya no podremos
    comprobar que el resultado devuelto por el algoritmo es correcto por dos
    motivos en especial: llegaremos a un punto donde probaremos con instancias
    muy grandes como para saber a ciencia cierta cual debe ser el resultado y
    pues decidimos darle un grado importante (sino principal) de aletoriedad
    a la selecci\'on/generaci\'on de estas intancias.

\par Para medir la complejidad se decidi\'o usar el \emph{clock} del sistema,
    el mismo es un n\'umero global relacionado al hardware/sistema operativo
    que se incrementa con cada instrucci\'on ejecutada por el ordenador. La idea
    es tomar este n\'umero \footnote{%
    \url{http://www.cplusplus.com/reference/chrono/high_resolution_clock/now/}}
    justo antes e inmediatamente despu\'es de que corra nuestro algoritmo
    (dejando de lado -siguiendo las directivas del enunciado de este TP-
    todas aquellas funcionalidades encargadas de cosas ajenas, como
    por ejemplo el \emph{parseo}\footnote{%
    \url{http://es.wikipedia.org/wiki/Analizador_sint\%C3\%A1ctico}} de los datos
    de entrada/salida). Luego, alcanza con calcular la diferencia entre estos dos
    valores para saber cu\'anto tiempo insumi\'o el programa para arribar a una soluci\'on.

\par El problema de esta metodolog\'ia para medir la complejidad es que no
    toma en cuenta que junto con nuestro algoritmo se encuentra ejecut\'ando
    muchas otras aplicaciones (\emph{Winning Eleven, Mortal Kombat, etc}, las
    cuales "comparten" el tiemp de CPU. Es decir, el sistema operativo podr\'ia
    (m\'as a\'un, lo hace) desalojar nuestra tarea del procesador y pasar a
    ejecutar otras cosas. Luego ser\'a nuevamente el turno de nuestra
    aplicaci\'on, la que podr\'a terminar. Pero mientras todo esto ocurr\'ia,
    el contador global de "clock" del sistema sigui\'o increment\'andose. Es
    decir, no llegamos a una medida exacta de lo que tar\'o nuestro programa.

\par Por estos motivos decidimos, para cada instancia del problema, ejecutarla
    m\'as de una vez (5 veces, en particular) y luego quedarnos con aquella
    ejecuci\'on que requiri\'o menos tiempo en terminar. As\'i
    conseguimos eliminar \emph{Outliers} y poder decir que tenemos una medida
    lo suficientemente precisa.
